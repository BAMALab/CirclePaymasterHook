"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  AccountType: () => AccountType,
  BaseProvider: () => BaseProvider,
  ContractAddress: () => ContractAddress,
  EIP1193Provider: () => EIP1193Provider,
  ModularWalletsProvider: () => ModularWalletsProvider,
  OwnerIdentifierType: () => OwnerIdentifierType,
  PaymasterProvider: () => PaymasterProvider,
  RpProvider: () => RpProvider,
  WebAuthnMode: () => WebAuthnMode,
  createAddressMapping: () => createAddressMapping,
  createRpClient: () => createRpClient,
  encodeTransfer: () => encodeTransfer,
  estimateExecuteRecoveryGas: () => estimateExecuteRecoveryGas,
  estimateRegisterRecoveryAddressGas: () => estimateRegisterRecoveryAddressGas,
  executeRecovery: () => executeRecovery,
  getAddress: () => getAddress,
  getAddressMapping: () => getAddressMapping,
  getLoginOptions: () => getLoginOptions,
  getLoginVerification: () => getLoginVerification,
  getModularWalletAddress: () => getModularWalletAddress,
  getRegistrationOptions: () => getRegistrationOptions,
  getRegistrationVerification: () => getRegistrationVerification,
  getUserOperationGasPrice: () => getUserOperationGasPrice,
  modularWalletActions: () => modularWalletActions,
  recoveryActions: () => recoveryActions,
  registerRecoveryAddress: () => registerRecoveryAddress,
  rpActions: () => rpActions,
  signAndWrap: () => signAndWrap,
  toCircleModularWalletClient: () => toCircleModularWalletClient,
  toCircleSmartAccount: () => toCircleSmartAccount,
  toModularTransport: () => toModularTransport,
  toPasskeyTransport: () => toPasskeyTransport,
  toWebAuthnCredential: () => toWebAuthnCredential,
  walletClientToLocalAccount: () => walletClientToLocalAccount,
  webAuthnSign: () => webAuthnSign
});
module.exports = __toCommonJS(index_exports);

// src/utils/address/computeAddress.ts
var import_viem13 = require("viem");

// src/constants/contractAddress.ts
var ContractAddress = /* @__PURE__ */ ((ContractAddress2) => {
  ContractAddress2["Arbitrum_USDC"] = "0xaf88d065e77c8cC2239327C5EDb3A432268e5831";
  ContractAddress2["Arbitrum_ARB"] = "0x912CE59144191C1204E64559FE8253a0e49E6548";
  ContractAddress2["ArbitrumSepolia_USDC"] = "0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d";
  ContractAddress2["Base_USDC"] = "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913";
  ContractAddress2["BaseSepolia_USDC"] = "0x036CbD53842c5426634e7929541eC2318f3dCF7e";
  ContractAddress2["Optimism_USDC"] = "0x0b2c639c533813f4aa9d7837caf62653d097ff85";
  ContractAddress2["Optimism_OP"] = "0x4200000000000000000000000000000000000042";
  ContractAddress2["OptimismSepolia_USDC"] = "0x5fd84259d66Cd46123540766Be93DFE6D43130D7";
  ContractAddress2["Polygon_USDC"] = "0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359";
  ContractAddress2["PolygonAmoy_USDC"] = "0x41e94eb019c0762f9bfcf9fb1e58725bfb0e7582";
  ContractAddress2["Unichain_USDC"] = "0x078D782b760474a361dDA0AF3839290b0EF57AD6";
  ContractAddress2["UnichainSepolia_USDC"] = "0x31d0220469e10c4E71834a79b1f276d740d3768F";
  return ContractAddress2;
})(ContractAddress || {});

// src/constants/provider.ts
var MODULAR_WALLETS_TRANSPORT_KEY = "Modular wallets transport";
var MODULAR_WALLETS_TRANSPORT_NAME = "Modular wallets transport";

// src/constants/smartAccount.ts
var import_account_abstraction = require("viem/account-abstraction");

// src/abis/authenticatorData.ts
var AUTHENTICATOR_DATA = [
  {
    components: [
      {
        components: [
          {
            internalType: "bytes",
            name: "authenticatorData",
            type: "bytes"
          },
          {
            internalType: "string",
            name: "clientDataJSON",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "challengeIndex",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "typeIndex",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "requireUserVerification",
            type: "bool"
          }
        ],
        internalType: "struct WebAuthnData",
        name: "webAuthnData",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "r",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "s",
        type: "uint256"
      }
    ],
    name: "WebAuthnSigDynamicPart",
    type: "tuple"
  }
];

// src/abis/factory.ts
var CIRCLE_MSCA_6900_V1_EP07_FACTORY_ABI = [
  {
    inputs: [
      { internalType: "address", name: "_owner", type: "address" },
      { internalType: "address", name: "_entryPointAddr", type: "address" },
      { internalType: "address", name: "_pluginManagerAddr", type: "address" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  { inputs: [], name: "Create2FailedDeployment", type: "error" },
  { inputs: [], name: "InvalidInitializationInput", type: "error" },
  { inputs: [], name: "InvalidLength", type: "error" },
  {
    inputs: [{ internalType: "address", name: "owner", type: "address" }],
    name: "OwnableInvalidOwner",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "OwnableUnauthorizedAccount",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "plugin", type: "address" }],
    name: "PluginIsNotAllowed",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "proxy",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "sender",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "salt",
        type: "bytes32"
      }
    ],
    name: "AccountCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "factory",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "accountImplementation",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "entryPoint",
        type: "address"
      }
    ],
    name: "FactoryDeployed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferStarted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    inputs: [],
    name: "ACCOUNT_IMPLEMENTATION",
    outputs: [
      { internalType: "contract UpgradableMSCA", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "ENTRY_POINT",
    outputs: [
      { internalType: "contract IEntryPoint", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint32", name: "_unstakeDelaySec", type: "uint32" }
    ],
    name: "addStake",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "_sender", type: "bytes32" },
      { internalType: "bytes32", name: "_salt", type: "bytes32" },
      { internalType: "bytes", name: "_initializingData", type: "bytes" }
    ],
    name: "createAccount",
    outputs: [
      {
        internalType: "contract UpgradableMSCA",
        name: "account",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "_sender", type: "bytes32" },
      { internalType: "bytes32", name: "_salt", type: "bytes32" },
      { internalType: "bytes", name: "_initializingData", type: "bytes" }
    ],
    name: "getAddress",
    outputs: [
      { internalType: "address", name: "addr", type: "address" },
      { internalType: "bytes32", name: "mixedSalt", type: "bytes32" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "isPluginAllowed",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pendingOwner",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address[]", name: "_plugins", type: "address[]" },
      { internalType: "bool[]", name: "_permissions", type: "bool[]" }
    ],
    name: "setPlugins",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unlockStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address payable",
        name: "_withdrawAddress",
        type: "address"
      }
    ],
    name: "withdrawStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// src/abis/initializingData.ts
var INITIALIZING_DATA_ABI_PARAMS = [
  { name: "plugins", type: "address[]" },
  { name: "manifestHashes", type: "bytes32[]" },
  { name: "pluginInstallData", type: "bytes[]" }
];

// src/abis/plugin.ts
var CIRCLE_PLUGIN_INSTALL_DATA_ABI = [
  { name: "initialOwners", type: "address[]" },
  { name: "ownerWeights", type: "uint256[]" },
  {
    name: "initialPublicKeyOwners",
    type: "tuple[]",
    components: [
      { name: "x", type: "uint256" },
      { name: "y", type: "uint256" }
    ]
  },
  { name: "publicKeyOwnerWeights", type: "uint256[]" },
  { name: "thresholdWeight", type: "uint256" }
];
var CIRCLE_PLUGIN_ADD_OWNERS_ABI = [
  {
    inputs: [
      {
        internalType: "address[]",
        name: "ownersToAdd",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "weightsToAdd",
        type: "uint256[]"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "x",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "y",
            type: "uint256"
          }
        ],
        internalType: "struct PublicKey[]",
        name: "publicKeyOwnersToAdd",
        type: "tuple[]"
      },
      {
        internalType: "uint256[]",
        name: "publicKeyWeightsToAdd",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "newThresholdWeight",
        type: "uint256"
      }
    ],
    name: "addOwners",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// src/abis/publicKeyCoordinates.ts
var PUBLIC_KEY_COORDINATES_ABI = [
  { name: "x", type: "uint256" },
  { name: "y", type: "uint256" }
];

// src/abis/upgradableMsca.ts
var CIRCLE_MSCA_6900_V1_EP07_ABI = [
  {
    inputs: [
      {
        internalType: "contract IEntryPoint",
        name: "_newEntryPoint",
        type: "address"
      },
      {
        internalType: "contract PluginManager",
        name: "_newPluginManager",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [{ internalType: "address", name: "target", type: "address" }],
    name: "AddressEmptyCode",
    type: "error"
  },
  {
    inputs: [
      { internalType: "address", name: "implementation", type: "address" }
    ],
    name: "ERC1967InvalidImplementation",
    type: "error"
  },
  { inputs: [], name: "ERC1967NonPayable", type: "error" },
  {
    inputs: [
      { internalType: "address", name: "plugin", type: "address" },
      { internalType: "bytes4", name: "selector", type: "bytes4" }
    ],
    name: "ExecFromPluginToSelectorNotPermitted",
    type: "error"
  },
  {
    inputs: [],
    name: "ExecuteFromPluginToExternalNotPermitted",
    type: "error"
  },
  { inputs: [], name: "FailedInnerCall", type: "error" },
  { inputs: [], name: "InvalidAuthorizer", type: "error" },
  {
    inputs: [{ internalType: "bytes4", name: "selector", type: "bytes4" }],
    name: "InvalidExecutionFunction",
    type: "error"
  },
  {
    inputs: [{ internalType: "uint8", name: "functionId", type: "uint8" }],
    name: "InvalidHookFunctionId",
    type: "error"
  },
  { inputs: [], name: "InvalidInitialization", type: "error" },
  { inputs: [], name: "InvalidInitializationInput", type: "error" },
  { inputs: [], name: "InvalidLimit", type: "error" },
  {
    inputs: [{ internalType: "uint8", name: "functionId", type: "uint8" }],
    name: "InvalidValidationFunctionId",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "plugin", type: "address" }],
    name: "NativeTokenSpendingNotPermitted",
    type: "error"
  },
  { inputs: [], name: "NotFoundSelector", type: "error" },
  { inputs: [], name: "NotInitializing", type: "error" },
  {
    inputs: [{ internalType: "bytes4", name: "selector", type: "bytes4" }],
    name: "NotNativeFunctionSelector",
    type: "error"
  },
  {
    inputs: [
      { internalType: "address", name: "plugin", type: "address" },
      { internalType: "uint8", name: "functionId", type: "uint8" },
      { internalType: "bytes", name: "revertReason", type: "bytes" }
    ],
    name: "PostExecHookFailed",
    type: "error"
  },
  {
    inputs: [
      { internalType: "address", name: "plugin", type: "address" },
      { internalType: "uint8", name: "functionId", type: "uint8" },
      { internalType: "bytes", name: "revertReason", type: "bytes" }
    ],
    name: "PreExecHookFailed",
    type: "error"
  },
  {
    inputs: [
      { internalType: "address", name: "plugin", type: "address" },
      { internalType: "uint8", name: "functionId", type: "uint8" },
      { internalType: "bytes", name: "revertReason", type: "bytes" }
    ],
    name: "PreRuntimeValidationHookFailed",
    type: "error"
  },
  {
    inputs: [
      { internalType: "address", name: "plugin", type: "address" },
      { internalType: "uint8", name: "functionId", type: "uint8" },
      { internalType: "bytes", name: "revertReason", type: "bytes" }
    ],
    name: "RuntimeValidationFailed",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "plugin", type: "address" }],
    name: "TargetIsPlugin",
    type: "error"
  },
  { inputs: [], name: "UUPSUnauthorizedCallContext", type: "error" },
  {
    inputs: [{ internalType: "bytes32", name: "slot", type: "bytes32" }],
    name: "UUPSUnsupportedProxiableUUID",
    type: "error"
  },
  { inputs: [], name: "UnauthorizedCaller", type: "error" },
  { inputs: [], name: "WalletStorageIsInitialized", type: "error" },
  { inputs: [], name: "WalletStorageIsInitializing", type: "error" },
  { inputs: [], name: "WalletStorageIsNotInitializing", type: "error" },
  { inputs: [], name: "WrongTimeBounds", type: "error" },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint64",
        name: "version",
        type: "uint64"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "plugin",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "manifestHash",
        type: "bytes32"
      },
      {
        components: [
          { internalType: "address", name: "plugin", type: "address" },
          { internalType: "uint8", name: "functionId", type: "uint8" }
        ],
        indexed: false,
        internalType: "struct FunctionReference[]",
        name: "dependencies",
        type: "tuple[]"
      }
    ],
    name: "PluginInstalled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "plugin",
        type: "address"
      },
      {
        indexed: true,
        internalType: "bool",
        name: "onUninstallSucceeded",
        type: "bool"
      }
    ],
    name: "PluginUninstalled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "entryPointAddress",
        type: "address"
      }
    ],
    name: "UpgradableMSCAInitialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "Upgraded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [],
    name: "WalletStorageInitialized",
    type: "event"
  },
  { stateMutability: "payable", type: "fallback" },
  {
    inputs: [],
    name: "AUTHOR",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "ENTRY_POINT",
    outputs: [
      { internalType: "contract IEntryPoint", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "PLUGIN_MANAGER",
    outputs: [
      { internalType: "contract PluginManager", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "UPGRADE_INTERFACE_VERSION",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "VERSION",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "addDeposit",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "target", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
      { internalType: "bytes", name: "data", type: "bytes" }
    ],
    name: "execute",
    outputs: [{ internalType: "bytes", name: "returnData", type: "bytes" }],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "target", type: "address" },
          { internalType: "uint256", name: "value", type: "uint256" },
          { internalType: "bytes", name: "data", type: "bytes" }
        ],
        internalType: "struct Call[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "executeBatch",
    outputs: [{ internalType: "bytes[]", name: "returnData", type: "bytes[]" }],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes", name: "data", type: "bytes" }],
    name: "executeFromPlugin",
    outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "target", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
      { internalType: "bytes", name: "data", type: "bytes" }
    ],
    name: "executeFromPluginExternal",
    outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "getDeposit",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getEntryPoint",
    outputs: [
      { internalType: "contract IEntryPoint", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "selector", type: "bytes4" }],
    name: "getExecutionFunctionConfig",
    outputs: [
      {
        components: [
          { internalType: "address", name: "plugin", type: "address" },
          {
            components: [
              { internalType: "address", name: "plugin", type: "address" },
              { internalType: "uint8", name: "functionId", type: "uint8" }
            ],
            internalType: "struct FunctionReference",
            name: "userOpValidationFunction",
            type: "tuple"
          },
          {
            components: [
              { internalType: "address", name: "plugin", type: "address" },
              { internalType: "uint8", name: "functionId", type: "uint8" }
            ],
            internalType: "struct FunctionReference",
            name: "runtimeValidationFunction",
            type: "tuple"
          }
        ],
        internalType: "struct ExecutionFunctionConfig",
        name: "executionFunctionConfig",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "selector", type: "bytes4" }],
    name: "getExecutionHooks",
    outputs: [
      {
        components: [
          {
            components: [
              { internalType: "address", name: "plugin", type: "address" },
              { internalType: "uint8", name: "functionId", type: "uint8" }
            ],
            internalType: "struct FunctionReference",
            name: "preExecHook",
            type: "tuple"
          },
          {
            components: [
              { internalType: "address", name: "plugin", type: "address" },
              { internalType: "uint8", name: "functionId", type: "uint8" }
            ],
            internalType: "struct FunctionReference",
            name: "postExecHook",
            type: "tuple"
          }
        ],
        internalType: "struct ExecutionHooks[]",
        name: "executionHooks",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getInstalledPlugins",
    outputs: [
      { internalType: "address[]", name: "pluginAddresses", type: "address[]" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getNonce",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "selector", type: "bytes4" }],
    name: "getPreValidationHooks",
    outputs: [
      {
        components: [
          { internalType: "address", name: "plugin", type: "address" },
          { internalType: "uint8", name: "functionId", type: "uint8" }
        ],
        internalType: "struct FunctionReference[]",
        name: "preUserOpValidationHooks",
        type: "tuple[]"
      },
      {
        components: [
          { internalType: "address", name: "plugin", type: "address" },
          { internalType: "uint8", name: "functionId", type: "uint8" }
        ],
        internalType: "struct FunctionReference[]",
        name: "preRuntimeValidationHooks",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address[]", name: "plugins", type: "address[]" },
      { internalType: "bytes32[]", name: "manifestHashes", type: "bytes32[]" },
      { internalType: "bytes[]", name: "pluginInstallData", type: "bytes[]" }
    ],
    name: "initializeUpgradableMSCA",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "plugin", type: "address" },
      { internalType: "bytes32", name: "manifestHash", type: "bytes32" },
      { internalType: "bytes", name: "pluginInstallData", type: "bytes" },
      {
        components: [
          { internalType: "address", name: "plugin", type: "address" },
          { internalType: "uint8", name: "functionId", type: "uint8" }
        ],
        internalType: "struct FunctionReference[]",
        name: "dependencies",
        type: "tuple[]"
      }
    ],
    name: "installPlugin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "address", name: "", type: "address" },
      { internalType: "uint256[]", name: "", type: "uint256[]" },
      { internalType: "uint256[]", name: "", type: "uint256[]" },
      { internalType: "bytes", name: "", type: "bytes" }
    ],
    name: "onERC1155BatchReceived",
    outputs: [{ internalType: "bytes4", name: "", type: "bytes4" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "address", name: "", type: "address" },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "bytes", name: "", type: "bytes" }
    ],
    name: "onERC1155Received",
    outputs: [{ internalType: "bytes4", name: "", type: "bytes4" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "address", name: "", type: "address" },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "bytes", name: "", type: "bytes" }
    ],
    name: "onERC721Received",
    outputs: [{ internalType: "bytes4", name: "", type: "bytes4" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "proxiableUUID",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "operator", type: "address" },
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "bytes", name: "userData", type: "bytes" },
      { internalType: "bytes", name: "operatorData", type: "bytes" }
    ],
    name: "tokensReceived",
    outputs: [],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "plugin", type: "address" },
      { internalType: "bytes", name: "config", type: "bytes" },
      { internalType: "bytes", name: "pluginUninstallData", type: "bytes" }
    ],
    name: "uninstallPlugin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "newImplementation", type: "address" },
      { internalType: "bytes", name: "data", type: "bytes" }
    ],
    name: "upgradeToAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "sender", type: "address" },
          { internalType: "uint256", name: "nonce", type: "uint256" },
          { internalType: "bytes", name: "initCode", type: "bytes" },
          { internalType: "bytes", name: "callData", type: "bytes" },
          {
            internalType: "bytes32",
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          { internalType: "bytes32", name: "gasFees", type: "bytes32" },
          { internalType: "bytes", name: "paymasterAndData", type: "bytes" },
          { internalType: "bytes", name: "signature", type: "bytes" }
        ],
        internalType: "struct PackedUserOperation",
        name: "userOp",
        type: "tuple"
      },
      { internalType: "bytes32", name: "userOpHash", type: "bytes32" },
      { internalType: "uint256", name: "missingAccountFunds", type: "uint256" }
    ],
    name: "validateUserOp",
    outputs: [
      { internalType: "uint256", name: "validationData", type: "uint256" }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address payable",
        name: "withdrawAddress",
        type: "address"
      },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "withdrawDepositTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
];

// src/constants/smartAccount.ts
var ENTRY_POINT_07 = {
  abi: import_account_abstraction.entryPoint07Abi,
  address: import_account_abstraction.entryPoint07Address,
  version: "0.7"
};
var FACTORY = {
  abi: CIRCLE_MSCA_6900_V1_EP07_FACTORY_ABI,
  address: "0x0000000DF7E6c9Dc387cAFc5eCBfa6c3a6179AdD"
};
var UPGRADABLE_MSCA = {
  abi: CIRCLE_MSCA_6900_V1_EP07_ABI,
  address: "0xA70F1296869DA9D7CB69578123F21888E6dB2B62"
};
var CIRCLE_WEIGHTED_WEB_AUTHN_MULTISIG_PLUGIN = {
  address: "0x0000000C984AFf541D6cE86Bb697e68ec57873C8",
  manifestHash: "0xa043327d77a74c1c55cfa799284b831fe09535a88b9f5fa4173d334e5ba0fd91"
};
var ERC1769_PROXY = {
  creationCode: "0x60806040526102d38038038061001481610194565b92833981019060408183031261018f5780516001600160a01b03811680820361018f5760208381015190936001600160401b03821161018f570184601f8201121561018f5780519061006d610068836101cf565b610194565b9582875285838301011161018f57849060005b83811061017b57505060009186010152813b15610163577f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80546001600160a01b03191682179055604051907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b600080a28351156101455750600080848461012c96519101845af4903d1561013c573d61011c610068826101cf565b908152600081943d92013e6101ea565b505b6040516085908161024e8239f35b606092506101ea565b9250505034610154575061012e565b63b398979f60e01b8152600490fd5b60249060405190634c9c8ce360e01b82526004820152fd5b818101830151888201840152869201610080565b600080fd5b6040519190601f01601f191682016001600160401b038111838210176101b957604052565b634e487b7160e01b600052604160045260246000fd5b6001600160401b0381116101b957601f01601f191660200190565b9061021157508051156101ff57805190602001fd5b604051630a12f52160e11b8152600490fd5b81511580610244575b610222575090565b604051639996b31560e01b81526001600160a01b039091166004820152602490fd5b50803b1561021a56fe60806040527f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc54600090819081906001600160a01b0316368280378136915af43d82803e15604b573d90f35b3d90fdfea26469706673582212204c5a8d3706486893377786ce0546dcd68cc8da5f34f8cc074c787db78fc29df764736f6c63430008180033"
};
var OWNER_WEIGHTS = [1n];
var THRESHOLD_WEIGHT = 1n;
var STUB_SIGNATURE = "0x0000be58786f7ae825e097256fc83a4749b95189e03e9963348373e9c595b15200000000000000000000000000000000000000000000000000000000000000412200000000000000000000000000000000000000000000000000000000000002400000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000006091077742edaf8be2fa866827236532ec2a5547fe2721e606ba591d1ffae7a15c022e5f8fe5614bbf65ea23ad3781910eb04a1a60fae88190001ecf46e5f5680a00000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000001700000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002549960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d9763050000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000867b2274797065223a22776562617574686e2e676574222c226368616c6c656e6765223a224b6d62474d316a4d554b57794d6352414c6774553953537144384841744867486178564b6547516b503541222c226f726967696e223a22687474703a2f2f6c6f63616c686f73743a35313733222c2263726f73734f726967696e223a66616c73657d0000000000000000000000000000000000000000000000000000";
var REPLAY_SAFE_HASH_V1 = {
  name: "Weighted Multisig Webauthn Plugin",
  primaryType: "CircleWeightedWebauthnMultisigMessage",
  domainSeparatorType: "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)",
  moduleType: "CircleWeightedWebauthnMultisigMessage(bytes32 hash)",
  version: "1.0.0"
};
var EIP712_PREFIX = "0x1901";
var MINIMUM_VERIFICATION_GAS_LIMIT = 1e5;
var MINIMUM_UNDEPLOY_VERIFICATION_GAS_LIMIT = 15e5;

// src/utils/address/getSalt.ts
var import_viem = require("viem");
function getSalt() {
  return (0, import_viem.pad)("0x", { size: 32 });
}

// src/utils/address/getSenderForContract.ts
var import_viem10 = require("viem");

// src/clients/createRpClient.ts
var import_viem6 = require("viem");

// src/actions/modularWallets/getAddress.ts
async function getAddress(client, params) {
  return await client.request({
    method: "circle_getAddress",
    params
  });
}

// src/actions/modularWallets/getAddressMapping.ts
async function getAddressMapping(client, parameters) {
  return await client.request({
    method: "circle_getAddressMapping",
    params: [parameters]
  });
}

// src/actions/modularWallets/createAddressMapping.ts
async function createAddressMapping(client, parameters) {
  return await client.request({
    method: "circle_createAddressMapping",
    params: [parameters]
  });
}

// src/actions/modularWallets/getUserOperationGasPrice.ts
async function getUserOperationGasPrice(client) {
  return await client.request({
    method: "circle_getUserOperationGasPrice",
    params: []
  });
}

// src/actions/recovery/estimateRegisterRecoveryAddressGas.ts
var import_viem2 = require("viem");
var import_account_abstraction2 = require("viem/account-abstraction");
async function estimateRegisterRecoveryAddressGas(client, params) {
  const { recoveryAddress, ...userOp } = params;
  const callData = (0, import_viem2.encodeFunctionData)({
    abi: CIRCLE_PLUGIN_ADD_OWNERS_ABI,
    functionName: "addOwners",
    args: [
      [recoveryAddress],
      // recovery address
      [BigInt(1)],
      // weightsToAdd
      [],
      // publicKeyOwnersToAdd
      [],
      // publicKeyWeightsToAdd
      BigInt(0)
      // newThresholdWeight, 0 means no change
    ]
  });
  return await (0, import_account_abstraction2.estimateUserOperationGas)(client, {
    callData,
    ...userOp
  });
}

// src/actions/recovery/estimateExecuteRecoveryGas.ts
var import_viem3 = require("viem");
var import_account_abstraction3 = require("viem/account-abstraction");
var import_webauthn_p256 = require("webauthn-p256");
async function estimateExecuteRecoveryGas(client, params) {
  const { credential, ...userOp } = params;
  const publicKeyOwner = (0, import_webauthn_p256.parsePublicKey)(credential.publicKey);
  const callData = (0, import_viem3.encodeFunctionData)({
    abi: CIRCLE_PLUGIN_ADD_OWNERS_ABI,
    functionName: "addOwners",
    args: [
      [],
      // ownersToAdd
      [],
      // weightsToAdd
      [publicKeyOwner],
      // publicKeyOwnersToAdd
      [BigInt(1)],
      // publicKeyWeightsToAdd
      BigInt(1)
      // newThresholdWeight
    ]
  });
  return await (0, import_account_abstraction3.estimateUserOperationGas)(client, {
    callData,
    ...userOp
  });
}

// src/actions/recovery/executeRecovery.ts
var import_viem4 = require("viem");
var import_account_abstraction4 = require("viem/account-abstraction");
var import_webauthn_p2562 = require("webauthn-p256");

// src/types/modularWallets.ts
var AccountType = /* @__PURE__ */ ((AccountType2) => {
  AccountType2["WebAuthn"] = "webAuthn";
  AccountType2["Local"] = "local";
  return AccountType2;
})(AccountType || {});
var OwnerIdentifierType = /* @__PURE__ */ ((OwnerIdentifierType2) => {
  OwnerIdentifierType2["EOA"] = "EOAOWNER";
  OwnerIdentifierType2["WebAuthn"] = "WEBAUTHOWNER";
  return OwnerIdentifierType2;
})(OwnerIdentifierType || {});

// src/types/rp.ts
var WebAuthnMode = /* @__PURE__ */ ((WebAuthnMode2) => {
  WebAuthnMode2["Login"] = "Login";
  WebAuthnMode2["Register"] = "Register";
  return WebAuthnMode2;
})(WebAuthnMode || {});

// src/actions/recovery/executeRecovery.ts
async function executeRecovery(client, params) {
  if (!client.account && !params.account) {
    throw new Error("Account is required");
  }
  const account = client.account || params.account;
  const { credential, ...userOp } = params;
  const publicKeyOwner = (0, import_webauthn_p2562.parsePublicKey)(credential.publicKey);
  try {
    await createAddressMapping(client, {
      walletAddress: account.address,
      owners: [
        {
          type: "WEBAUTHOWNER" /* WebAuthn */,
          identifier: {
            publicKeyX: publicKeyOwner.x.toString(),
            publicKeyY: publicKeyOwner.y.toString()
          }
        }
      ]
    });
  } catch (error) {
    const addressMappingAlreadyExistsError = error instanceof import_viem4.RpcError && error.code === -32602 /* ALREADY_KNOWN */;
    if (!addressMappingAlreadyExistsError) {
      throw new Error(
        "Failed to register the new WebAuthn credential. Please try again."
      );
    }
  }
  const callData = (0, import_viem4.encodeFunctionData)({
    abi: CIRCLE_PLUGIN_ADD_OWNERS_ABI,
    functionName: "addOwners",
    args: [
      [],
      // ownersToAdd
      [],
      // weightsToAdd
      [publicKeyOwner],
      // publicKeyOwnersToAdd
      [BigInt(1)],
      // publicKeyWeightsToAdd
      BigInt(1)
      // newThresholdWeight
    ]
  });
  return await (0, import_account_abstraction4.sendUserOperation)(client, {
    callData,
    ...userOp
  });
}

// src/actions/recovery/registerRecoveryAddress.ts
var import_viem5 = require("viem");
var import_account_abstraction5 = require("viem/account-abstraction");
async function registerRecoveryAddress(client, params) {
  if (!client.account && !params.account) {
    throw new Error("Account is required");
  }
  const account = client.account || params.account;
  const { recoveryAddress, ...userOp } = params;
  try {
    await createAddressMapping(client, {
      walletAddress: account.address,
      owners: [
        {
          type: "EOAOWNER" /* EOA */,
          identifier: {
            address: recoveryAddress
          }
        }
      ]
    });
  } catch (error) {
    const addressMappingAlreadyExistsError = error instanceof import_viem5.RpcError && error.code === -32602 /* ALREADY_KNOWN */;
    if (!addressMappingAlreadyExistsError) {
      throw new Error(
        "Failed to register the recovery address. Please try again."
      );
    }
  }
  const callData = (0, import_viem5.encodeFunctionData)({
    abi: CIRCLE_PLUGIN_ADD_OWNERS_ABI,
    functionName: "addOwners",
    args: [
      [recoveryAddress],
      // recovery address
      [BigInt(1)],
      // weightsToAdd
      [],
      // publicKeyOwnersToAdd
      [],
      // publicKeyWeightsToAdd
      BigInt(0)
      // newThresholdWeight, 0 means no change
    ]
  });
  return await (0, import_account_abstraction5.sendUserOperation)(client, {
    callData,
    ...userOp
  });
}

// src/actions/rp/getLoginOptions.ts
async function getLoginOptions(client, { userId }) {
  return await client.request({
    method: "rp_getLoginOptions",
    params: [userId]
  });
}

// src/actions/rp/getLoginVerification.ts
async function getLoginVerification(client, { credential }) {
  return await client.request({
    method: "rp_getLoginVerification",
    params: [credential]
  });
}

// src/actions/rp/getRegistrationOptions.ts
async function getRegistrationOptions(client, { username }) {
  return await client.request({
    method: "rp_getRegistrationOptions",
    params: [username]
  });
}

// src/actions/rp/getRegistrationVerification.ts
async function getRegistrationVerification(client, { credential }) {
  return await client.request({
    method: "rp_getRegistrationVerification",
    params: [credential]
  });
}

// src/clients/decorators/modularWallet.ts
function modularWalletActions(client) {
  return {
    getAddress: (parameters) => getAddress(client, parameters),
    createAddressMapping: (parameters) => createAddressMapping(client, parameters),
    getAddressMapping: (parameters) => getAddressMapping(client, parameters),
    getUserOperationGasPrice: () => getUserOperationGasPrice(client)
  };
}

// src/clients/decorators/recovery.ts
function recoveryActions(client) {
  return {
    estimateRegisterRecoveryAddressGas: (parameters) => estimateRegisterRecoveryAddressGas(client, parameters),
    estimateExecuteRecoveryGas: (parameters) => estimateExecuteRecoveryGas(client, parameters),
    executeRecovery: (parameters) => executeRecovery(client, parameters),
    registerRecoveryAddress: (parameters) => registerRecoveryAddress(client, parameters)
  };
}

// src/clients/decorators/rp.ts
function rpActions(client) {
  return {
    getLoginOptions: (parameters) => getLoginOptions(client, parameters),
    getLoginVerification: (parameters) => getLoginVerification(client, parameters),
    getRegistrationOptions: (parameters) => getRegistrationOptions(client, parameters),
    getRegistrationVerification: (parameters) => getRegistrationVerification(client, parameters)
  };
}

// src/clients/createRpClient.ts
function createRpClient(parameters) {
  const { key = "rp", name = "RP Client", transport } = parameters;
  const client = (0, import_viem6.createClient)({
    ...parameters,
    key,
    name,
    transport,
    type: "RpClient"
  });
  return client.extend(rpActions);
}

// src/clients/toCircleModularWalletClient.ts
function toCircleModularWalletClient({
  client
}) {
  const circleModularWalletClient = client.extend(modularWalletActions);
  return circleModularWalletClient;
}

// src/clients/transports/toModularTransport.ts
var import_viem7 = require("viem");

// ../../node_modules/.pnpm/web3-errors@1.3.1/node_modules/web3-errors/lib/esm/error_codes.js
var ERR_METHOD_NOT_IMPLEMENTED = 202;
var ERR_MULTIPLE_ERRORS = 208;
var ERR_INVALID_PROVIDER = 601;
var JSONRPC_ERR_REJECTED_REQUEST = 4001;
var JSONRPC_ERR_UNAUTHORIZED = 4100;
var JSONRPC_ERR_UNSUPPORTED_METHOD = 4200;
var JSONRPC_ERR_DISCONNECTED = 4900;
var JSONRPC_ERR_CHAIN_DISCONNECTED = 4901;
var ERR_RPC_INVALID_JSON = -32700;
var ERR_RPC_INVALID_REQUEST = -32600;
var ERR_RPC_INVALID_METHOD = -32601;
var ERR_RPC_INVALID_PARAMS = -32602;
var ERR_RPC_INTERNAL_ERROR = -32603;
var ERR_RPC_INVALID_INPUT = -32e3;
var ERR_RPC_MISSING_RESOURCE = -32001;
var ERR_RPC_UNAVAILABLE_RESOURCE = -32002;
var ERR_RPC_TRANSACTION_REJECTED = -32003;
var ERR_RPC_UNSUPPORTED_METHOD = -32004;
var ERR_RPC_LIMIT_EXCEEDED = -32005;
var ERR_RPC_NOT_SUPPORTED = -32006;

// ../../node_modules/.pnpm/web3-errors@1.3.1/node_modules/web3-errors/lib/esm/web3_error_base.js
var BaseWeb3Error = class extends Error {
  /**
   * @deprecated Use the `cause` property instead.
   */
  get innerError() {
    if (this.cause instanceof MultipleErrors) {
      return this.cause.errors;
    }
    return this.cause;
  }
  /**
   * @deprecated Use the `cause` property instead.
   */
  set innerError(cause) {
    if (Array.isArray(cause)) {
      this.cause = new MultipleErrors(cause);
    } else {
      this.cause = cause;
    }
  }
  constructor(msg, cause) {
    super(msg);
    if (Array.isArray(cause)) {
      this.cause = new MultipleErrors(cause);
    } else {
      this.cause = cause;
    }
    this.name = this.constructor.name;
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(new.target.constructor);
    } else {
      this.stack = new Error().stack;
    }
  }
  static convertToString(value, unquotValue = false) {
    if (value === null || value === void 0)
      return "undefined";
    const result = JSON.stringify(value, (_, v) => typeof v === "bigint" ? v.toString() : v);
    return unquotValue && ["bigint", "string"].includes(typeof value) ? result.replace(/['\\"]+/g, "") : result;
  }
  toJSON() {
    return {
      name: this.name,
      code: this.code,
      message: this.message,
      cause: this.cause,
      // deprecated
      innerError: this.cause
    };
  }
};
var MultipleErrors = class extends BaseWeb3Error {
  constructor(errors) {
    super(`Multiple errors occurred: [${errors.map((e) => e.message).join("], [")}]`);
    this.code = ERR_MULTIPLE_ERRORS;
    this.errors = errors;
  }
};

// ../../node_modules/.pnpm/web3-errors@1.3.1/node_modules/web3-errors/lib/esm/errors/generic_errors.js
var MethodNotImplementedError = class extends BaseWeb3Error {
  constructor() {
    super("The method you're trying to call is not implemented.");
    this.code = ERR_METHOD_NOT_IMPLEMENTED;
  }
};

// ../../node_modules/.pnpm/web3-errors@1.3.1/node_modules/web3-errors/lib/esm/errors/provider_errors.js
var InvalidProviderError = class extends BaseWeb3Error {
  constructor(clientUrl) {
    super(`Provider with url "${clientUrl}" is not set or invalid`);
    this.clientUrl = clientUrl;
    this.code = ERR_INVALID_PROVIDER;
  }
};

// ../../node_modules/.pnpm/web3-errors@1.3.1/node_modules/web3-errors/lib/esm/errors/rpc_error_messages.js
var genericRpcErrorMessageTemplate = "An Rpc error has occured with a code of *code*";
var RpcErrorMessages = {
  //  EIP-1474 & JSON RPC 2.0
  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1474.md
  [ERR_RPC_INVALID_JSON]: {
    message: "Parse error",
    description: "Invalid JSON"
  },
  [ERR_RPC_INVALID_REQUEST]: {
    message: "Invalid request",
    description: "JSON is not a valid request object	"
  },
  [ERR_RPC_INVALID_METHOD]: {
    message: "Method not found",
    description: "Method does not exist	"
  },
  [ERR_RPC_INVALID_PARAMS]: {
    message: "Invalid params",
    description: "Invalid method parameters"
  },
  [ERR_RPC_INTERNAL_ERROR]: {
    message: "Internal error",
    description: "Internal JSON-RPC error"
  },
  [ERR_RPC_INVALID_INPUT]: {
    message: "Invalid input",
    description: "Missing or invalid parameters"
  },
  [ERR_RPC_MISSING_RESOURCE]: {
    message: "Resource not found",
    description: "Requested resource not found"
  },
  [ERR_RPC_UNAVAILABLE_RESOURCE]: {
    message: "Resource unavailable",
    description: "Requested resource not available"
  },
  [ERR_RPC_TRANSACTION_REJECTED]: {
    message: "Transaction rejected",
    description: "Transaction creation failed"
  },
  [ERR_RPC_UNSUPPORTED_METHOD]: {
    message: "Method not supported",
    description: "Method is not implemented"
  },
  [ERR_RPC_LIMIT_EXCEEDED]: {
    message: "Limit exceeded",
    description: "Request exceeds defined limit"
  },
  [ERR_RPC_NOT_SUPPORTED]: {
    message: "JSON-RPC version not supported",
    description: "Version of JSON-RPC protocol is not supported"
  },
  // EIP-1193
  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1193.md#provider-errors
  [JSONRPC_ERR_REJECTED_REQUEST]: {
    name: "User Rejected Request",
    message: "The user rejected the request."
  },
  [JSONRPC_ERR_UNAUTHORIZED]: {
    name: "Unauthorized",
    message: "The requested method and/or account has not been authorized by the user."
  },
  [JSONRPC_ERR_UNSUPPORTED_METHOD]: {
    name: "Unsupported Method",
    message: "The Provider does not support the requested method."
  },
  [JSONRPC_ERR_DISCONNECTED]: {
    name: "Disconnected",
    message: "The Provider is disconnected from all chains."
  },
  [JSONRPC_ERR_CHAIN_DISCONNECTED]: {
    name: "Chain Disconnected",
    message: "The Provider is not connected to the requested chain."
  },
  // EIP-1193 - CloseEvent
  // https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent/code
  "0-999": {
    name: "",
    message: "Not used."
  },
  1e3: {
    name: "Normal Closure",
    message: "The connection successfully completed the purpose for which it was created."
  },
  1001: {
    name: "Going Away",
    message: "The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection."
  },
  1002: {
    name: "Protocol error",
    message: "The endpoint is terminating the connection due to a protocol error."
  },
  1003: {
    name: "Unsupported Data",
    message: "The connection is being terminated because the endpoint received data of a type it cannot accept. (For example, a text-only endpoint received binary data.)"
  },
  1004: {
    name: "Reserved",
    message: "Reserved. A meaning might be defined in the future."
  },
  1005: {
    name: "No Status Rcvd",
    message: "Reserved. Indicates that no status code was provided even though one was expected."
  },
  1006: {
    name: "Abnormal Closure",
    message: "Reserved. Indicates that a connection was closed abnormally (that is, with no close frame being sent) when a status code is expected."
  },
  1007: {
    name: "Invalid frame payload data",
    message: "The endpoint is terminating the connection because a message was received that contained inconsistent data (e.g., non-UTF-8 data within a text message)."
  },
  1008: {
    name: "Policy Violation",
    message: "The endpoint is terminating the connection because it received a message that violates its policy. This is a generic status code, used when codes 1003 and 1009 are not suitable."
  },
  1009: {
    name: "Message Too Big",
    message: "The endpoint is terminating the connection because a data frame was received that is too large."
  },
  1010: {
    name: "Mandatory Ext.",
    message: "The client is terminating the connection because it expected the server to negotiate one or more extension, but the server didn't."
  },
  1011: {
    name: "Internal Error",
    message: "The server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request."
  },
  1012: {
    name: "Service Restart",
    message: "The server is terminating the connection because it is restarting."
  },
  1013: {
    name: "Try Again Later",
    message: "The server is terminating the connection due to a temporary condition, e.g. it is overloaded and is casting off some of its clients."
  },
  1014: {
    name: "Bad Gateway",
    message: "The server was acting as a gateway or proxy and received an invalid response from the upstream server. This is similar to 502 HTTP Status Code."
  },
  1015: {
    name: "TLS handshake",
    message: "Reserved. Indicates that the connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can't be verified)."
  },
  "1016-2999": {
    name: "",
    message: "For definition by future revisions of the WebSocket Protocol specification, and for definition by extension specifications."
  },
  "3000-3999": {
    name: "",
    message: "For use by libraries, frameworks, and applications. These status codes are registered directly with IANA. The interpretation of these codes is undefined by the WebSocket protocol."
  },
  "4000-4999": {
    name: "",
    message: "For private use, and thus can't be registered. Such codes can be used by prior agreements between WebSocket applications. The interpretation of these codes is undefined by the WebSocket protocol."
  }
};

// ../../node_modules/.pnpm/web3-errors@1.3.1/node_modules/web3-errors/lib/esm/errors/rpc_errors.js
var RpcError3 = class extends BaseWeb3Error {
  constructor(rpcError, message) {
    super(message !== null && message !== void 0 ? message : genericRpcErrorMessageTemplate.replace("*code*", rpcError.error.code.toString()));
    this.code = rpcError.error.code;
    this.id = rpcError.id;
    this.jsonrpc = rpcError.jsonrpc;
    this.jsonRpcError = rpcError.error;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { error: this.jsonRpcError, id: this.id, jsonRpc: this.jsonrpc });
  }
};
var ParseError = class extends RpcError3 {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_INVALID_JSON].message);
    this.code = ERR_RPC_INVALID_JSON;
  }
};
var InvalidRequestError = class extends RpcError3 {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_INVALID_REQUEST].message);
    this.code = ERR_RPC_INVALID_REQUEST;
  }
};
var MethodNotFoundError = class extends RpcError3 {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_INVALID_METHOD].message);
    this.code = ERR_RPC_INVALID_METHOD;
  }
};
var InvalidParamsError = class extends RpcError3 {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_INVALID_PARAMS].message);
    this.code = ERR_RPC_INVALID_PARAMS;
  }
};
var InternalError = class extends RpcError3 {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_INTERNAL_ERROR].message);
    this.code = ERR_RPC_INTERNAL_ERROR;
  }
};
var InvalidInputError = class extends RpcError3 {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_INVALID_INPUT].message);
    this.code = ERR_RPC_INVALID_INPUT;
  }
};
var MethodNotSupported = class extends RpcError3 {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_UNSUPPORTED_METHOD].message);
    this.code = ERR_RPC_UNSUPPORTED_METHOD;
  }
};
var ResourceUnavailableError = class extends RpcError3 {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_UNAVAILABLE_RESOURCE].message);
    this.code = ERR_RPC_UNAVAILABLE_RESOURCE;
  }
};
var ResourcesNotFoundError = class extends RpcError3 {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_MISSING_RESOURCE].message);
    this.code = ERR_RPC_MISSING_RESOURCE;
  }
};
var VersionNotSupportedError = class extends RpcError3 {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_NOT_SUPPORTED].message);
    this.code = ERR_RPC_NOT_SUPPORTED;
  }
};
var TransactionRejectedError = class extends RpcError3 {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_TRANSACTION_REJECTED].message);
    this.code = ERR_RPC_TRANSACTION_REJECTED;
  }
};
var LimitExceededError = class extends RpcError3 {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_LIMIT_EXCEEDED].message);
    this.code = ERR_RPC_LIMIT_EXCEEDED;
  }
};
var rpcErrorsMap = /* @__PURE__ */ new Map();
rpcErrorsMap.set(ERR_RPC_INVALID_JSON, { error: ParseError });
rpcErrorsMap.set(ERR_RPC_INVALID_REQUEST, {
  error: InvalidRequestError
});
rpcErrorsMap.set(ERR_RPC_INVALID_METHOD, {
  error: MethodNotFoundError
});
rpcErrorsMap.set(ERR_RPC_INVALID_PARAMS, { error: InvalidParamsError });
rpcErrorsMap.set(ERR_RPC_INTERNAL_ERROR, { error: InternalError });
rpcErrorsMap.set(ERR_RPC_INVALID_INPUT, { error: InvalidInputError });
rpcErrorsMap.set(ERR_RPC_UNSUPPORTED_METHOD, {
  error: MethodNotSupported
});
rpcErrorsMap.set(ERR_RPC_UNAVAILABLE_RESOURCE, {
  error: ResourceUnavailableError
});
rpcErrorsMap.set(ERR_RPC_TRANSACTION_REJECTED, {
  error: TransactionRejectedError
});
rpcErrorsMap.set(ERR_RPC_MISSING_RESOURCE, {
  error: ResourcesNotFoundError
});
rpcErrorsMap.set(ERR_RPC_NOT_SUPPORTED, {
  error: VersionNotSupportedError
});
rpcErrorsMap.set(ERR_RPC_LIMIT_EXCEEDED, { error: LimitExceededError });

// ../../node_modules/.pnpm/web3-types@1.10.0/node_modules/web3-types/lib/esm/data_format_types.js
var FMT_NUMBER;
(function(FMT_NUMBER2) {
  FMT_NUMBER2["NUMBER"] = "NUMBER_NUMBER";
  FMT_NUMBER2["HEX"] = "NUMBER_HEX";
  FMT_NUMBER2["STR"] = "NUMBER_STR";
  FMT_NUMBER2["BIGINT"] = "NUMBER_BIGINT";
})(FMT_NUMBER || (FMT_NUMBER = {}));
var FMT_BYTES;
(function(FMT_BYTES2) {
  FMT_BYTES2["HEX"] = "BYTES_HEX";
  FMT_BYTES2["UINT8ARRAY"] = "BYTES_UINT8ARRAY";
})(FMT_BYTES || (FMT_BYTES = {}));
var DEFAULT_RETURN_FORMAT = {
  number: FMT_NUMBER.BIGINT,
  bytes: FMT_BYTES.HEX
};
var ETH_DATA_FORMAT = { number: FMT_NUMBER.HEX, bytes: FMT_BYTES.HEX };

// ../../node_modules/.pnpm/web3-types@1.10.0/node_modules/web3-types/lib/esm/eth_types.js
var BlockTags;
(function(BlockTags2) {
  BlockTags2["EARLIEST"] = "earliest";
  BlockTags2["LATEST"] = "latest";
  BlockTags2["PENDING"] = "pending";
  BlockTags2["SAFE"] = "safe";
  BlockTags2["FINALIZED"] = "finalized";
  BlockTags2["COMMITTED"] = "committed";
})(BlockTags || (BlockTags = {}));
var HardforksOrdered;
(function(HardforksOrdered2) {
  HardforksOrdered2["chainstart"] = "chainstart";
  HardforksOrdered2["frontier"] = "frontier";
  HardforksOrdered2["homestead"] = "homestead";
  HardforksOrdered2["dao"] = "dao";
  HardforksOrdered2["tangerineWhistle"] = "tangerineWhistle";
  HardforksOrdered2["spuriousDragon"] = "spuriousDragon";
  HardforksOrdered2["byzantium"] = "byzantium";
  HardforksOrdered2["constantinople"] = "constantinople";
  HardforksOrdered2["petersburg"] = "petersburg";
  HardforksOrdered2["istanbul"] = "istanbul";
  HardforksOrdered2["muirGlacier"] = "muirGlacier";
  HardforksOrdered2["berlin"] = "berlin";
  HardforksOrdered2["london"] = "london";
  HardforksOrdered2["altair"] = "altair";
  HardforksOrdered2["arrowGlacier"] = "arrowGlacier";
  HardforksOrdered2["grayGlacier"] = "grayGlacier";
  HardforksOrdered2["bellatrix"] = "bellatrix";
  HardforksOrdered2["merge"] = "merge";
  HardforksOrdered2["capella"] = "capella";
  HardforksOrdered2["shanghai"] = "shanghai";
})(HardforksOrdered || (HardforksOrdered = {}));

// ../../node_modules/.pnpm/web3-types@1.10.0/node_modules/web3-types/lib/esm/primitives_types.js
var TypedArray = Object.getPrototypeOf(Uint8Array);

// ../../node_modules/.pnpm/web3-types@1.10.0/node_modules/web3-types/lib/esm/web3_base_provider.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var symbol = Symbol.for("web3/base-provider");
var Web3BaseProvider = class _Web3BaseProvider {
  static isWeb3Provider(provider) {
    return provider instanceof _Web3BaseProvider || Boolean(provider && provider[symbol]);
  }
  // To match an object "instanceof" does not work if
  // matcher class and object is using different package versions
  // to overcome this bottleneck used this approach.
  // The symbol value for one string will always remain same regardless of package versions
  // eslint-disable-next-line class-methods-use-this
  get [symbol]() {
    return true;
  }
  /**
   * @deprecated Please use `.request` instead.
   * @param payload - Request Payload
   * @param callback - Callback
   */
  send(payload, callback) {
    this.request(payload).then((response) => {
      callback(null, response);
    }).catch((err) => {
      callback(err);
    });
  }
  /**
   * @deprecated Please use `.request` instead.
   * @param payload - Request Payload
   */
  sendAsync(payload) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.request(payload);
    });
  }
  /**
   * Modify the return type of the request method to be fully compatible with EIP-1193
   *
   * [deprecated] In the future major releases (\>= v5) all providers are supposed to be fully compatible with EIP-1193.
   * So this method will not be needed and would not be available in the future.
   *
   * @returns A new instance of the provider with the request method fully compatible with EIP-1193
   *
   * @example
   * ```ts
   * const provider = new Web3HttpProvider('http://localhost:8545');
   * const fullyCompatibleProvider = provider.asEIP1193Provider();
   * const result = await fullyCompatibleProvider.request({ method: 'eth_getBalance' });
   * console.log(result); // '0x0234c8a3397aab58' or something like that
   * ```
   */
  asEIP1193Provider() {
    const newObj = Object.create(this);
    const originalRequest = newObj.request;
    newObj.request = function request(args) {
      return __awaiter(this, void 0, void 0, function* () {
        const response = yield originalRequest(args);
        return response.result;
      });
    };
    newObj.asEIP1193Provider = void 0;
    return newObj;
  }
};

// src/providers/base/provider.ts
var BaseProvider = class extends Web3BaseProvider {
  constructor() {
    super();
  }
  /**
   * This is an abstract method from the parent class but we don't need it for this provider.
   * @throws MethodNotImplementedError.
   */
  getStatus() {
    throw new MethodNotImplementedError();
  }
  /**
   * This is an abstract method from the parent class but we don't need it for this provider.
   * @Returns false.
   */
  supportsSubscriptions() {
    return false;
  }
  /**
   * This is an abstract method from the parent class but we don't need it for this provider.
   * @throws MethodNotImplementedError.
   */
  on() {
    throw new MethodNotImplementedError();
  }
  /**
   * This is an abstract method from the parent class but we don't need it for this provider.
   * @throws MethodNotImplementedError.
   */
  removeListener() {
    throw new MethodNotImplementedError();
  }
  /**
   * This is an abstract method from the parent class but we don't need it for this provider.
   * @throws MethodNotImplementedError.
   */
  once() {
    throw new MethodNotImplementedError();
  }
  /**
   * This is an abstract method from the parent class but we don't need it for this provider.
   * @throws MethodNotImplementedError.
   */
  removeAllListeners() {
    throw new MethodNotImplementedError();
  }
  /**
   * This is an abstract method from the parent class but we don't need it for this provider.
   * @throws MethodNotImplementedError.
   */
  connect() {
    throw new MethodNotImplementedError();
  }
  /**
   * This is an abstract method from the parent class but we don't need it for this provider.
   * @throws MethodNotImplementedError.
   */
  disconnect() {
    throw new MethodNotImplementedError();
  }
  /**
   * This is an abstract method from the parent class but we don't need it for this provider.
   * @throws MethodNotImplementedError.
   */
  reset() {
    throw new MethodNotImplementedError();
  }
  /**
   * This is an abstract method from the parent class but we don't need it for this provider.
   * @throws MethodNotImplementedError.
   */
  reconnect() {
    throw new MethodNotImplementedError();
  }
};

// src/providers/modular-wallets/provider.ts
var ModularWalletsProvider = class extends BaseProvider {
  clientUrl;
  clientKey;
  constructor(clientUrl, clientKey) {
    super();
    if (!validateClientUrl(clientUrl)) {
      throw new InvalidProviderError(clientUrl);
    }
    this.clientUrl = clientUrl;
    this.clientKey = clientKey;
  }
  async request(payload, requestOptions) {
    switch (payload.method) {
      case "eth_supportedEntryPoints":
      case "eth_sendUserOperation":
      case "eth_estimateUserOperationGas":
      case "eth_getUserOperationByHash":
      case "eth_getUserOperationReceipt":
      case "eth_chainId":
      case "eth_getBalance":
      case "eth_blockNumber":
      case "eth_call":
      case "eth_getBlockByNumber":
      case "eth_maxPriorityFeePerGas":
      case "eth_gasPrice":
      case "eth_getCode":
      case "circle_getAddress":
      case "circle_getAddressMapping":
      case "circle_createAddressMapping":
      case "circle_getUserOperationGasPrice":
      case "pm_getPaymasterData":
      case "pm_getPaymasterStubData": {
        const response = await fetchFromApi(this.clientUrl, this.clientKey, payload, requestOptions);
        return response.result;
      }
      default:
        throw new MethodNotImplementedError();
    }
  }
};

// src/providers/paymaster/provider.ts
var PaymasterProvider = class extends BaseProvider {
  clientUrl;
  clientKey;
  constructor(clientUrl, clientKey) {
    super();
    if (!validateClientUrl(clientUrl)) {
      throw new InvalidProviderError(clientUrl);
    }
    this.clientUrl = clientUrl;
    this.clientKey = clientKey;
  }
  async request(payload, requestOptions) {
    switch (payload.method) {
      case "pm_getPaymasterData":
      case "pm_getPaymasterStubData": {
        const response = await fetchFromApi(this.clientUrl, this.clientKey, payload, requestOptions);
        return response.result;
      }
      default:
        throw new MethodNotImplementedError();
    }
  }
};

// src/providers/rp/provider.ts
var RpProvider = class extends BaseProvider {
  clientUrl;
  clientKey;
  constructor(clientUrl, clientKey) {
    super();
    if (!validateClientUrl(clientUrl)) {
      throw new InvalidProviderError(clientUrl);
    }
    this.clientUrl = clientUrl;
    this.clientKey = clientKey;
  }
  async request(payload, requestOptions) {
    switch (payload.method) {
      case "rp_getLoginOptions":
      case "rp_getLoginVerification":
      case "rp_getRegistrationOptions":
      case "rp_getRegistrationVerification":
        return (await fetchFromApi(
          this.clientUrl,
          this.clientKey,
          payload,
          requestOptions
        )).result;
      default:
        throw new MethodNotImplementedError();
    }
  }
};

// src/providers/eip-1193/provider.ts
var EIP1193Provider = class extends BaseProvider {
  publicClient;
  bundlerClient;
  constructor(bundlerClient, publicClient) {
    super();
    this.bundlerClient = bundlerClient;
    this.publicClient = publicClient;
    if (this.bundlerClient.account === void 0) {
      throw new Error("Account is required");
    }
  }
  async request(payload) {
    const { method, params } = payload;
    switch (method) {
      case "eth_accounts":
      case "eth_requestAccounts": {
        const address = await this.bundlerClient.account.getAddress();
        return this.getResponse([address], payload);
      }
      case "personal_sign": {
        const [challenge, address] = params;
        await this.validateAddress(address);
        const result = await this.bundlerClient.account.signMessage({
          message: challenge
        });
        return this.getResponse(result, payload);
      }
      case "eth_sendTransaction": {
        const [{ data, to, value }] = params;
        if (!to) throw new Error("Missing to address");
        const userOpHash = await this.bundlerClient.sendUserOperation({
          calls: [
            {
              to,
              value: value ?? BigInt(0),
              data: data ?? "0x"
            }
          ],
          account: this.bundlerClient.account
        });
        const { receipt } = await this.bundlerClient.waitForUserOperationReceipt({
          hash: userOpHash
        });
        return this.getResponse(receipt.transactionHash, payload);
      }
      case "eth_getTransactionReceipt": {
        const [hash] = params;
        const receipt = await this.publicClient.waitForTransactionReceipt({
          hash
        });
        return this.getResponse(receipt, payload);
      }
      case "eth_signTypedData_v4": {
        const [address, typedData] = params;
        await this.validateAddress(address);
        const result = await this.bundlerClient.account.signTypedData(typedData);
        return this.getResponse(result, payload);
      }
      default: {
        const result = await this.bundlerClient.transport.request(payload);
        return this.getResponse(result, payload);
      }
    }
  }
  /**
   * Validates the specified address.
   * @param address - The address to validate.
   */
  async validateAddress(address) {
    const clientAddress = await this.bundlerClient.account.getAddress();
    if (clientAddress !== address) {
      throw new Error("Invalid account");
    }
  }
  /**
   * Creates a JSON-RPC response with the specified result.
   * @param result - The result to include in the response.
   * @param payload - The payload of the request.
   */
  getResponse(result, payload) {
    const { jsonrpc, id } = payload;
    return {
      result,
      jsonrpc,
      id
    };
  }
};

// src/clients/transports/toModularTransport.ts
var toModularTransport = (clientUrl, clientKey) => {
  const provider = new ModularWalletsProvider(clientUrl, clientKey);
  const config = isCircleUrl(provider.clientUrl) ? {
    key: MODULAR_WALLETS_TRANSPORT_KEY,
    name: MODULAR_WALLETS_TRANSPORT_NAME
  } : void 0;
  return (0, import_viem7.custom)(provider, config);
};

// src/clients/transports/toPasskeyTransport.ts
var import_viem8 = require("viem");
var toPasskeyTransport = (clientUrl, clientKey) => {
  const provider = new RpProvider(clientUrl, clientKey);
  const config = isCircleUrl(provider.clientUrl) ? {
    key: MODULAR_WALLETS_TRANSPORT_KEY,
    name: MODULAR_WALLETS_TRANSPORT_NAME
  } : void 0;
  return (0, import_viem8.custom)(provider, config);
};

// src/utils/smartAccount/getDefaultVerificationGasLimit.ts
var getDefaultVerificationGasLimit = async (client, deployed) => {
  try {
    const modularWalletClient = client.extend(modularWalletActions);
    const result = await modularWalletClient.getUserOperationGasPrice();
    const verificationGasLimit = deployed ? Number(result?.deployed ?? MINIMUM_VERIFICATION_GAS_LIMIT) : Number(result?.notDeployed ?? MINIMUM_UNDEPLOY_VERIFICATION_GAS_LIMIT);
    return verificationGasLimit;
  } catch (_error) {
    return deployed ? MINIMUM_VERIFICATION_GAS_LIMIT : MINIMUM_UNDEPLOY_VERIFICATION_GAS_LIMIT;
  }
};

// src/utils/smartAccount/isWebAuthnOwner.ts
function isWebAuthnOwner(owner) {
  return owner.type === "webAuthn" /* WebAuthn */;
}

// src/utils/smartAccount/walletClientToLocalAccount.ts
var import_accounts = require("viem/accounts");
function walletClientToLocalAccount(walletClient) {
  if (!walletClient.account) {
    throw new Error("WalletClient does not have an associated account.");
  }
  return (0, import_accounts.toAccount)({
    address: walletClient.account.address,
    async signMessage(params) {
      return await walletClient.signMessage(params);
    },
    async signTransaction(transaction) {
      return await walletClient.signTransaction(
        transaction
      );
    },
    async signTypedData(typedData) {
      return await walletClient.signTypedData(
        typedData
      );
    }
  });
}

// src/utils/address/getPublicKeyParamsFromOwner.ts
var import_viem9 = require("viem");
var import_webauthn_p2563 = require("webauthn-p256");
function getPublicKeyParamsFromOwner(owner) {
  const publicKey = (0, import_webauthn_p2563.parsePublicKey)(owner.publicKey);
  const initialPublicKeyOwners = [publicKey];
  const sender = (0, import_viem9.keccak256)(
    (0, import_viem9.encodeAbiParameters)(PUBLIC_KEY_COORDINATES_ABI, [
      initialPublicKeyOwners[0].x,
      initialPublicKeyOwners[0].y
    ])
  );
  return { sender, initialPublicKeyOwners };
}

// src/utils/address/getSenderForContract.ts
function getSenderForContract(owner) {
  return isWebAuthnOwner(owner) ? getPublicKeyParamsFromOwner(owner).sender : (0, import_viem10.pad)(owner.address);
}

// src/utils/address/initializeUpgradableMSCA.ts
var import_viem12 = require("viem");

// src/utils/address/getPluginInstallParams.ts
var import_viem11 = require("viem");
function getPluginInstallParams(owner) {
  return isWebAuthnOwner(owner) ? (0, import_viem11.encodeAbiParameters)(CIRCLE_PLUGIN_INSTALL_DATA_ABI, [
    [],
    [],
    getPublicKeyParamsFromOwner(owner).initialPublicKeyOwners,
    OWNER_WEIGHTS,
    THRESHOLD_WEIGHT
  ]) : (0, import_viem11.encodeAbiParameters)(CIRCLE_PLUGIN_INSTALL_DATA_ABI, [
    [owner.address],
    OWNER_WEIGHTS,
    [],
    [],
    THRESHOLD_WEIGHT
  ]);
}

// src/utils/address/initializeUpgradableMSCA.ts
function getInitializeUpgradableMSCAData(owner) {
  const pluginInstallParams = getPluginInstallParams(owner);
  return (0, import_viem12.encodeFunctionData)({
    abi: UPGRADABLE_MSCA.abi,
    functionName: "initializeUpgradableMSCA",
    args: [
      [CIRCLE_WEIGHTED_WEB_AUTHN_MULTISIG_PLUGIN.address],
      [CIRCLE_WEIGHTED_WEB_AUTHN_MULTISIG_PLUGIN.manifestHash],
      [pluginInstallParams]
    ]
  });
}
function getInitializeUpgradableMSCAParams(owner) {
  const pluginInstallParams = getPluginInstallParams(owner);
  return (0, import_viem12.encodeAbiParameters)(INITIALIZING_DATA_ABI_PARAMS, [
    [CIRCLE_WEIGHTED_WEB_AUTHN_MULTISIG_PLUGIN.address],
    [CIRCLE_WEIGHTED_WEB_AUTHN_MULTISIG_PLUGIN.manifestHash],
    [pluginInstallParams]
  ]);
}

// src/utils/address/computeAddress.ts
function computeAddress(owner) {
  const sender = getSenderForContract(owner);
  const salt = getSalt();
  const initializeUpgradableMSCAData = getInitializeUpgradableMSCAData(owner);
  const mixedSalt = (0, import_viem13.keccak256)(
    (0, import_viem13.encodeAbiParameters)(
      [{ type: "bytes32" }, { type: "bytes32" }],
      [sender, salt]
    )
  );
  const bytecode = (0, import_viem13.encodePacked)(
    ["bytes", "bytes"],
    [
      ERC1769_PROXY.creationCode,
      (0, import_viem13.encodeAbiParameters)((0, import_viem13.parseAbiParameters)("address, bytes"), [
        UPGRADABLE_MSCA.address,
        initializeUpgradableMSCAData
      ])
    ]
  );
  const address = (0, import_viem13.getContractAddress)({
    bytecode,
    from: FACTORY.address,
    opcode: "CREATE2",
    salt: mixedSalt
  });
  return address;
}

// src/utils/encoding/encodeTransfer.ts
var import_viem14 = require("viem");
function encodeTransfer(to, token, amount) {
  const data = (0, import_viem14.encodeFunctionData)({
    abi: import_viem14.erc20Abi,
    functionName: "transfer",
    args: [to, amount]
  });
  return { data, to: token };
}

// src/utils/publicKey/parseBase64EncodedPublicKey.ts
var import_webauthn_p2564 = require("webauthn-p256");
async function parseBase64EncodedPublicKey(base64Url) {
  const bytes = (0, import_webauthn_p2564.base64UrlToBytes)(base64Url);
  const cryptoKey = await (0, import_webauthn_p2564.bytesToCryptoKey)(bytes);
  const publicKey = await (0, import_webauthn_p2564.cryptoKeyToBytes)(cryptoKey);
  return (0, import_webauthn_p2564.parsePublicKey)(publicKey);
}

// src/utils/rpc/fetchFromApi.ts
var import_uuid = require("uuid");
var import_viem15 = require("viem");
var import_web3 = require("web3");
async function fetchFromApi(clientUrl, clientKey, payload, requestOptions) {
  const fetchResponse = await fetch(clientUrl, {
    ...requestOptions,
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${clientKey}`,
      "X-AppInfo": `platform=web;version=${"1.0.9"};uri=${window?.location?.hostname}`
    },
    body: JSON.stringify({
      ...payload,
      jsonrpc: "2.0",
      id: payload?.id ?? (0, import_uuid.v4)()
    })
  });
  if (!fetchResponse.ok) {
    const errorResponse = await fetchResponse.json();
    throw new import_web3.ResponseError(
      errorResponse,
      void 0,
      void 0,
      fetchResponse.status
    );
  }
  const jsonResponse = await fetchResponse.json();
  if ("error" in jsonResponse) {
    const errorResponse = jsonResponse;
    throw new import_viem15.EIP1193ProviderRpcError(
      errorResponse.error.code,
      errorResponse.error.message
    );
  }
  return jsonResponse;
}

// src/utils/rpc/isCircleUrl.ts
function isCircleUrl(url) {
  try {
    const parsedUrl = new URL(url);
    const allowedHosts = [
      "modular-sdk.circle.com",
      "modular-sdk-staging.circle.com"
    ];
    return allowedHosts.includes(parsedUrl.host);
  } catch {
    return false;
  }
}

// src/utils/rpc/validateClientUrl.ts
function validateClientUrl(clientUrl) {
  try {
    const url = new URL(clientUrl);
    const urlPattern = /^(https?:\/\/)([\da-zA-Z.-]+)(:[\d]{1,5})?([/\w .-]*)*(\?[^\s]*)?$/;
    if (!urlPattern.test(clientUrl)) {
      return false;
    }
    return url.protocol === "http:" || url.protocol === "https:";
  } catch {
    return false;
  }
}

// src/utils/signature/toReplaySafeHash.ts
var import_viem16 = require("viem");
function toReplaySafeHash({
  address,
  chainId,
  hash
}) {
  const { name, version, domainSeparatorType, moduleType } = REPLAY_SAFE_HASH_V1;
  const domainSeparatorTypeHash = (0, import_viem16.keccak256)(
    (0, import_viem16.encodePacked)(["string"], [domainSeparatorType])
  );
  const moduleNameHash = (0, import_viem16.keccak256)((0, import_viem16.encodePacked)(["string"], [name]));
  const moduleVersionHash = (0, import_viem16.keccak256)((0, import_viem16.encodePacked)(["string"], [version]));
  const moduleTypeHash = (0, import_viem16.keccak256)((0, import_viem16.encodePacked)(["string"], [moduleType]));
  const domainSeparator = (0, import_viem16.keccak256)(
    (0, import_viem16.encodeAbiParameters)(
      [
        { type: "bytes32" },
        { type: "bytes32" },
        { type: "bytes32" },
        { type: "uint256" },
        { type: "address" },
        { type: "bytes32" }
      ],
      [
        domainSeparatorTypeHash,
        moduleNameHash,
        moduleVersionHash,
        BigInt(chainId),
        CIRCLE_WEIGHTED_WEB_AUTHN_MULTISIG_PLUGIN.address,
        (0, import_viem16.pad)(address, { dir: "right" })
      ]
    )
  );
  const structHash = (0, import_viem16.keccak256)(
    (0, import_viem16.encodeAbiParameters)(
      [{ type: "bytes32" }, { type: "bytes32" }],
      [moduleTypeHash, hash]
    )
  );
  return (0, import_viem16.keccak256)((0, import_viem16.concatHex)([EIP712_PREFIX, domainSeparator, structHash]));
}

// src/utils/signature/toWebAuthnSignature.ts
var import_viem17 = require("viem");
var import_webauthn_p2565 = require("webauthn-p256");
function toWebAuthnSignature({
  webauthn,
  signature
}) {
  const { r, s } = (0, import_webauthn_p2565.parseSignature)(signature);
  return (0, import_viem17.encodeAbiParameters)(AUTHENTICATOR_DATA, [
    {
      webAuthnData: {
        authenticatorData: webauthn.authenticatorData,
        clientDataJSON: (0, import_viem17.stringToHex)(webauthn.clientDataJSON),
        challengeIndex: BigInt(webauthn.challengeIndex),
        typeIndex: BigInt(webauthn.typeIndex),
        requireUserVerification: true
      },
      r,
      s
    }
  ]);
}

// src/utils/signature/wrapSignature.ts
var import_viem18 = require("viem");
function wrapSignature({
  sender,
  signature,
  hasUserOpGas
}) {
  const sigType = hasUserOpGas ? 34 : 2;
  return (0, import_viem18.encodePacked)(
    ["bytes32", "uint256", "uint8", "uint256", "bytes"],
    [sender, 65n, sigType, BigInt((0, import_viem18.size)(signature)), signature]
  );
}

// src/utils/signature/wrapEoaSignature.ts
var import_viem19 = require("viem");
function wrapEoaSignature({
  signature,
  hasUserOpGas
}) {
  const { r, s, v } = (0, import_viem19.parseSignature)(signature);
  if (typeof v !== "undefined") {
    const signType = hasUserOpGas ? Number(v + 32n) : Number(v);
    return (0, import_viem19.encodePacked)(["bytes32", "bytes32", "uint8"], [r, s, signType]);
  }
  throw new Error("signature is invalid");
}

// src/accounts/implementations/getDefaultWalletName.ts
function getDefaultWalletName(owner) {
  return isWebAuthnOwner(owner) ? `passkey-${(/* @__PURE__ */ new Date()).toISOString()}` : `wallet-${(/* @__PURE__ */ new Date()).toISOString()}`;
}

// src/accounts/implementations/getOwnersConfigFromOwner.ts
function getOwnersConfigFromOwner(owner) {
  if (isWebAuthnOwner(owner)) {
    const { initialPublicKeyOwners } = getPublicKeyParamsFromOwner(owner);
    const publicKeyX = initialPublicKeyOwners[0].x.toString();
    const publicKeyY = initialPublicKeyOwners[0].y.toString();
    return {
      webauthnOwners: [{ publicKeyX, publicKeyY, weight: 1 }]
    };
  }
  return {
    owners: [{ address: owner.address, weight: 1 }]
  };
}

// src/accounts/implementations/getModularWalletAddress.ts
async function getModularWalletAddress({
  client,
  owner,
  name = getDefaultWalletName(owner)
}) {
  const ownerConfig = getOwnersConfigFromOwner(owner);
  return await client.getAddress([
    {
      scaConfiguration: {
        initialOwnershipConfiguration: {
          weightedMultisig: {
            ...ownerConfig,
            thresholdWeight: 1
          }
        },
        scaCore: "circle_6900_v1"
      },
      metadata: {
        name
      }
    }
  ]);
}

// src/accounts/implementations/toCircleSmartAccount.ts
var import_viem21 = require("viem");
var import_account_abstraction6 = require("viem/account-abstraction");

// src/accounts/implementations/signAndWrap.ts
var import_viem20 = require("viem");

// src/accounts/implementations/webAuthnSign.ts
var webAuthnSign = async ({
  hash,
  owner
}) => {
  const { signature, webauthn } = await owner.sign({
    hash
  });
  return Promise.resolve(
    toWebAuthnSignature({
      signature,
      webauthn
    })
  );
};

// src/accounts/implementations/signAndWrap.ts
var signAndWrap = async ({
  hash,
  owner,
  sender,
  hasUserOpGas
}) => {
  if (isWebAuthnOwner(owner)) {
    const finalHash = hasUserOpGas ? (0, import_viem20.hashMessage)({ raw: hash }) : hash;
    const signature = await webAuthnSign({ hash: finalHash, owner });
    return wrapSignature({
      signature,
      sender,
      hasUserOpGas
    });
  }
  if (hasUserOpGas) {
    const signature = await owner.signMessage({
      message: { raw: hash }
    });
    return wrapEoaSignature({ signature, hasUserOpGas: true });
  }
  if (owner.sign) {
    const signature = await owner.sign({ hash });
    return wrapEoaSignature({ signature, hasUserOpGas: false });
  }
  throw new Error("`owner` does not support raw sign.");
};

// src/accounts/implementations/toCircleSmartAccount.ts
async function toCircleSmartAccount(parameters) {
  const { address, client, owner, name } = parameters;
  const publicClient = client.extend(import_viem21.publicActions);
  const sender = getSenderForContract(owner);
  const initializeUpgradableMSCAParams = getInitializeUpgradableMSCAParams(owner);
  const salt = getSalt();
  let deployed = false;
  let walletAddress;
  if (client.transport.key === MODULAR_WALLETS_TRANSPORT_KEY) {
    const circleModularWalletClient = toCircleModularWalletClient({ client });
    const wallet = await getModularWalletAddress({
      client: circleModularWalletClient,
      owner,
      name
    });
    walletAddress = wallet.address;
  }
  return (0, import_account_abstraction6.toSmartAccount)({
    client,
    entryPoint: ENTRY_POINT_07,
    extend: { abi: import_account_abstraction6.entryPoint07Abi, factory: FACTORY },
    getAddress: async function() {
      if (address) return Promise.resolve(address);
      if (walletAddress) return Promise.resolve(walletAddress);
      return Promise.resolve(computeAddress(owner));
    },
    encodeCalls: function(calls) {
      return Promise.resolve(
        (0, import_viem21.encodeFunctionData)(
          calls.length === 1 ? {
            abi: UPGRADABLE_MSCA.abi,
            functionName: "execute",
            args: [
              calls[0].to,
              calls[0].value ?? 0n,
              calls[0].data ?? "0x"
            ]
          } : {
            abi: UPGRADABLE_MSCA.abi,
            functionName: "executeBatch",
            args: [
              calls.map((call) => ({
                data: call.data ?? "0x",
                target: call.to,
                value: call.value ?? 0n
              }))
            ]
          }
        )
      );
    },
    async getFactoryArgs() {
      const factoryData = (0, import_viem21.encodeFunctionData)({
        abi: FACTORY.abi,
        functionName: "createAccount",
        args: [sender, salt, initializeUpgradableMSCAParams]
      });
      return Promise.resolve({ factory: FACTORY.address, factoryData });
    },
    async getStubSignature() {
      return Promise.resolve(STUB_SIGNATURE);
    },
    async sign(parameters2) {
      const address2 = await this.getAddress();
      const hash = toReplaySafeHash({
        address: address2,
        chainId: client.chain.id,
        hash: parameters2.hash
      });
      return signAndWrap({ hash, owner, sender });
    },
    async signMessage(parameters2) {
      const address2 = await this.getAddress();
      const hash = toReplaySafeHash({
        address: address2,
        chainId: client.chain.id,
        hash: (0, import_viem21.hashMessage)(parameters2.message)
      });
      return signAndWrap({
        hash,
        owner,
        sender
      });
    },
    async signTypedData(parameters2) {
      const { domain, types, primaryType, message } = parameters2;
      const address2 = await this.getAddress();
      const hash = toReplaySafeHash({
        address: address2,
        chainId: client.chain.id,
        hash: (0, import_viem21.hashTypedData)({
          domain,
          message,
          primaryType,
          types
        })
      });
      return signAndWrap({ hash, owner, sender });
    },
    async signUserOperation(parameters2) {
      const { chainId = client.chain.id, ...userOperation } = parameters2;
      const address2 = await this.getAddress();
      const userOperationHash = (0, import_account_abstraction6.getUserOperationHash)({
        chainId,
        entryPointAddress: ENTRY_POINT_07.address,
        entryPointVersion: ENTRY_POINT_07.version,
        userOperation: {
          ...userOperation,
          sender: address2
        }
      });
      const pubKeyId = (0, import_viem21.pad)((0, import_viem21.slice)(sender, 2));
      return signAndWrap({
        hash: userOperationHash,
        owner,
        sender: pubKeyId,
        hasUserOpGas: true
      });
    },
    userOperation: {
      async estimateGas(userOperation) {
        if (!deployed) {
          const code = await publicClient.getCode({
            address: walletAddress ?? computeAddress(owner)
          });
          deployed = code !== "0x" && Boolean(code);
        }
        const verificationGasLimit = userOperation.verificationGasLimit !== void 0 ? BigInt(userOperation.verificationGasLimit) : BigInt(await getDefaultVerificationGasLimit(client, deployed));
        return Promise.resolve({
          verificationGasLimit
        });
      }
    }
  });
}

// src/accounts/toWebAuthnCredential.ts
var import_webauthn_p2566 = require("webauthn-p256");
async function toWebAuthnCredential(parameters) {
  if (typeof window === "undefined" || window.navigator == null || window.navigator.credentials == null)
    throw new Error("Credential Management API not supported.");
  const { transport, username, credentialId, mode } = parameters;
  const client = createRpClient({ transport });
  return mode === "Login" /* Login */ ? await startAuthentication(client, credentialId) : await startRegistration(client, username);
}
async function startRegistration(client, username = null) {
  const createFn = window.navigator.credentials.create.bind(
    window.navigator.credentials
  );
  const registrationOptions = await client.getRegistrationOptions({
    username: username ?? ""
  });
  const credential = await createFn({
    publicKey: getCredentialCreationOptions(registrationOptions)
  });
  if (credential == null) throw new Error("No credential created.");
  await client.getRegistrationVerification({
    credential
  });
  try {
    const publicKey = await (0, import_webauthn_p2566.parseCredentialPublicKey)(
      new Uint8Array(
        credential.response.getPublicKey()
      )
    );
    return {
      id: credential.id,
      publicKey: (0, import_webauthn_p2566.serializePublicKey)(publicKey, { compressed: true }),
      raw: credential,
      rpId: registrationOptions.rp.id
    };
  } catch (error) {
    throw new Error(`Credential creation failed. ${error}`);
  }
}
async function startAuthentication(client, credentialId = null) {
  const getFn = window.navigator.credentials.get.bind(
    window.navigator.credentials
  );
  const loginOptions = await client.getLoginOptions({
    userId: credentialId ?? ""
  });
  const credential = await getFn({
    publicKey: getCredentialRequestOptions(loginOptions)
  });
  if (credential == null) throw new Error("No credential available.");
  const { publicKey: base64Url } = await client.getLoginVerification({
    credential
  });
  if (!base64Url) {
    throw new Error("Login verification failed.");
  }
  try {
    const publicKey = await parseBase64EncodedPublicKey(base64Url);
    return {
      id: credential.id,
      publicKey: (0, import_webauthn_p2566.serializePublicKey)(publicKey, { compressed: true }),
      raw: credential,
      rpId: loginOptions?.rpId
    };
  } catch (error) {
    throw new Error(`Credential creation failed. ${error}`);
  }
}
function getCredentialCreationOptions(options) {
  return {
    ...options,
    challenge: (0, import_webauthn_p2566.base64UrlToBytes)(options.challenge),
    user: {
      ...options.user,
      id: (0, import_webauthn_p2566.base64UrlToBytes)(options.user.id)
    }
  };
}
function getCredentialRequestOptions(options) {
  return {
    ...options,
    challenge: (0, import_webauthn_p2566.base64UrlToBytes)(options.challenge),
    allowCredentials: options.allowCredentials?.map((credential) => ({
      ...credential,
      id: (0, import_webauthn_p2566.base64UrlToBytes)(credential.id)
    }))
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AccountType,
  BaseProvider,
  ContractAddress,
  EIP1193Provider,
  ModularWalletsProvider,
  OwnerIdentifierType,
  PaymasterProvider,
  RpProvider,
  WebAuthnMode,
  createAddressMapping,
  createRpClient,
  encodeTransfer,
  estimateExecuteRecoveryGas,
  estimateRegisterRecoveryAddressGas,
  executeRecovery,
  getAddress,
  getAddressMapping,
  getLoginOptions,
  getLoginVerification,
  getModularWalletAddress,
  getRegistrationOptions,
  getRegistrationVerification,
  getUserOperationGasPrice,
  modularWalletActions,
  recoveryActions,
  registerRecoveryAddress,
  rpActions,
  signAndWrap,
  toCircleModularWalletClient,
  toCircleSmartAccount,
  toModularTransport,
  toPasskeyTransport,
  toWebAuthnCredential,
  walletClientToLocalAccount,
  webAuthnSign
});
